# DataSync Pipeline

Данный мини-проект демонстрирует использование Protobuf и FlatBuffers для сериализации данных.

## Возможности

- Генерация синтетических метрик серверов (CPU, память, диск).
- Сериализация данных в JSON, Protobuf и FlatBuffers.
- Передача данных через gRPC.
- Сравнение размера файлов и времени сериализации/десериализации.
- Построение графиков с помощью Matplotlib.
- Логирование всех операций в файлы и консоль.
- Проверки на ошибки (доступность сервера, корректность данных).

## Требования

- Docker
- Docker Compose

## Установка и запуск

1. **Склонируйте репозиторий**:
   ```bash
   git clone https://github.com/pawelasinski/datasync_pipeline.git
   cd datasync_pipeline
   ```

2. **Запустите проект**:
   ```bash
   docker compose up --build --no-cache
   ```
    - Сервер запустится на порту `50051`.
    - Клиент сгенерирует данные и отправит их на сервер.
    - Соответсвующий скрипт проанализирует данные и построит графики на основе их анализа.

3. **Проверьте результаты**:
    - Папка `results/` будет содержать:
        - `metrics.json`, `metrics.proto.bin`, `metrics.flatbuf` — сохраненные данные.
        - `serialize_times.json`, `deserialize_times.json` — замеры времени сериализации/десериализации.
        - `size_comparison.png`, `performance_comparison.png` — графики.
        - `logs/client.log`, `logs/server.log`, `logs/analysis.log` — логи.

4. **Остановите контейнеры**:
   ```bash
   docker compose down
   ```
    - Для очистки томов добавьте флаг `--volumes`: `docker compose down --volumes`.

## Файловая структура проекта

```text
datasync_pipeline/
├── client/                          # Клиентская часть
│   ├── Dockerfile                      # Docker-файл для клиента
│   ├── client.py                       # Генерация данных и отправка через gRPC
│   ├── data_generator.py               # Генерация синтетических метрик
│   └── serializers.py                  # Логика сериализации (JSON, Protobuf, FlatBuffers)
├── server/                          # Серверная часть
│   ├── Dockerfile                      # Docker-файл для сервера
│   ├── server.py                       # gRPC-сервер для приема данных
│   ├── storage.py                      # Сохранение данных в файлы
│   └── deserialize_performance.py      # Измерение времени и размера
├── proto/                           # Protobuf-схемы
│   └── metrics.proto                   # Схема для метрик серверов
├── flatbuffers_schema/              # FlatBuffers-схемы
│   └── metrics.fbs                     # Схема для метрик серверов
├── analysis/                        # Анализ результатов
│   ├── Dockerfile                      # Docker-файл для анализа
│   └── analyze.py                      # Сравнение и построение графиков
├── results/                         # Папка для результатов (файлов с данными, графиков и логов; будет монтироваться как том)
│   ├── logs/                           # Папка для логов (создается автоматически)
│   └── ...                             # Файлы с данными и графики
├── README.md                        # Описание проекта
├── docker-compose.yml               # Файл для управления всеми сервисами
└── requirements.txt                 # Зависимости
```

## Пример логов

```
...
2025-02-22 10:00:01,123 - INFO - JSON deserialization took 0.0023 seconds, size: 128 bytes
2025-02-22 10:00:01,124 - INFO - Protobuf deserialization took 0.0015 seconds, size: 64 bytes
2025-02-22 10:00:01,125 - INFO - FlatBuffers deserialization took 0.0010 seconds, size: 80 bytes
2025-02-22 10:00:01,126 - INFO - Processed 2 metrics in performance measurement.
...
```

## Возможное расширение проекта

- Интегрировать реальные данные вместо синтетических.
- Добавить поддержку других форматов (например, Avro).
- ...

## Лицензия

[MIT License](./LICENSE)

## Автор

Pawel Asinski (pawel.asinski@gmail.com)

---

## Protobuf vs. FlatBuffers

**Protobuf** (Protocol Buffers) и **FlatBuffers** — это два бинарных формата сериализации данных, разработанные Google.
Они применяются для эффективной передачи структурированных данных и подходят для различных сценариев: от микросервисов и
IoT-устройств до игровых движков и мобильных приложений.

### Краткий обзор

Основной фокус Protobuf — эффективная сериализация структурированных данных для сетевых передач (RPC, микросервисы и
т.д.), FlatBuffers — минимизация копирования данных (zero-copy) и быстрый прямой доступ к ним без предварительного
парсинга.

### Структура форматов

#### Protobuf

1. **Определение сообщений** в `.proto`-файлах:
   ```proto
   message Person {
       string name = 1;
       int32 age = 2;
   }
   ```
2. Данные записываются (кодируются) как поток байтов с **тегами** (номер поля + тип). Каждое поле имеет номер (например,
   name = 1, age = 2), и перед значением идет тег, который говорит: "Это поле номер 1, вот его данные". Это делает
   сериализацию компактной и даёт возможность пропускать неизвестные поля.
    ```text
    [0A 05 50 61 77 65 6C] [10 1C]
     field 1: "Pawel"   field 2: 28
    ```
   Здесь:
    - `0A` — это тег для строки (поле 1).
    - `05` — длина строки, потом "Pawel".
    - `10` — тег для числа (поле 2).
    - `1C` — это 28.
3. Данные компактные, но их нужно парсить при чтении: программа разбирает теги и значения, создает объекты в памяти.

#### FlatBuffers

1. **Определение схемы** в `.fbs`-файлах:
   ```fbs
   table Person {
       name: string;
       age: int;
   }
   ```
2. Данные записываются в "плоский" (потому что все данные укладываются в одну непрерывную последовательность байтов —
   как длинная лента, где всё идет подряд) буфер с таблицей указателей (offsets). Нет тегов перед каждым значением —
   вместо этого есть таблица в начале, которая указывает, где что лежит.
    ```text
    [04 00 00 00] [08 00] [0C 00] [05 00 00 00] [50 61 77 65 6C] [1C 00 00 00]
     служебные байты   таблица   длина строки   строка "Pawel"   возраст
    ```
   Здесь:
    - Данные:
        - Строка "Pawel":
            - Длина строки: 5 байтов (для "Pawel"), записывается как 4 байта (int): `05 00 00 00`.
            - Символы: байты для "P", "a", "w", "e", "l" в UTF-8: `50 61 77 65 6C`.
        - Число 28 (int): занимает 4 байта, в hex это `1C 00 00 00` (28 в десятичной системе).
    - Таблица с указателями (расстояние в байтах от начала таблицы до данных):
        - `08 00` — отступ на 8 байтов от начала таблицы до строки "Pawel".
        - `0C 00` — отступ на 12 байтов до возраста.
    - В начале буфера — служебные байты, указывающие на начало таблицы (например, её позицию):
        - `04 00 00 00` — смещение до таблицы.

3. Данные уже лежат в памяти в готовом виде (zero-copy), и их можно читать без парсинга, просто прыгая по указателям.

---

### Преимущества и недостатки

#### Protobuf

**Преимущества**:

1. Зрелая экосистема, множество инструментов и библиотек (нативная поддержка gRPC).
2. Широкая поддержка языков (C++, Python, Java и др.), удобна для проектов, где задействовано несколько языков.
3. Лёгкая эволюция схемы: можно добавлять новые поля с новыми тегами, а старый код их игнорирует.
4. Компактный бинарный формат, особенно эффективен по сравнению с XML/JSON.

**Недостатки**:

1. Необходима стадия компиляции `.proto`-файлов в код.
2. Для доступа к полям нужно распарсить всё сообщение.
3. Хотя экономия памяти лучше, чем у текстовых форматов, FlatBuffers в ряде сценариев ещё более эффективен.

#### FlatBuffers

**Преимущества**:

1. Zero-copy десериализация: прямой доступ к нужному полю из буфера без полного парсинга.
2. Эффективная работа с памятью (особенно в условиях ограниченных ресурсов: мобильные устройства, игры).
3. Высокая скорость чтения данных (особенно при частом обращении к элементам).
4. Поддержка простого JSON-формата для отладки (генератор `flatc` умеет преобразовывать и обратно).
5. Также немаленькая поддержка языков (C++, Python, Rust, TS и др.).

**Недостатки**:

1. Менее зрелая экосистема по сравнению с Protobuf, меньше готовых материалов в сообществе.
2. Сложность в освоении, особенно если приходится работать напрямую с буфером.
3. Правила эволюции схемы жёстче: нельзя менять порядок полей, удалять поля, кроме как пометив их `deprecated`.

---

### Эволюция схемы

#### Protobuf

- Добавление новых полей: просто указываются новые номера (например, `email = 3`).
- Старые поля можно резервировать через `reserved`, чтобы избежать конфликтов.
- Изменение типов требует осторожности (рекомендуется при несовместимом типе использовать новое поле).

#### FlatBuffers

- Новые поля добавляются строго в конец таблицы, чтобы бинарная структура не нарушалась.
- Старые поля удалять нельзя, только помечать `deprecated`, чтобы не ломать совместимость.
- Изменение числовых типов (например, `int` на `long`) требует проверки совместимости, иначе может возникнуть конфликт в
  бинарной схеме.

---

### Примеры на Python

#### Protobuf

**Шаг 1.** Создадим файл `person.proto`:

```proto
// Определяем правила сериализации/десериализации. Без этой строки по умолчанию используется proto2, что может привести к неожиданному поведению.
syntax = "proto3";

/*
 * Пространство имен example группирует все сообщения в этом файле.
 * Это предотвращает конфликты имен с другими схемами.
 */
package example;

message Person {
    // Поле name хранит имя человека в формате UTF-8.
    string name = 1; // Значение по умолчанию — "", если не задано.

    // Поле age указывает возраст как 32-битное целое число.
    int32 age = 2; // Значение по умолчанию — 0, если не задано.
}
```

**Шаг 2.** Скомпилируем `.proto` в Python-код (используя [grpc-tools](https://pypi.org/project/grpcio-tools/)):

```bash
python -m grpc_tools.protoc -I. --python_out=. person.proto
```

Будет сгенерирован файл `person_pb2.py`.

**Шаг 3.** Использование в коде Python:

```python
import example.person_pb2 as person_pb2

# Создаём объект сообщения Person.
# person_pb2.Person() — это конструктор класса Person, определенного в person.proto.
# Создается пустой объект, где поля name и age имеют значения по умолчанию ("" и 0 для proto3).
msg = person_pb2.Person()
msg.name = "Pawel"
msg.age = 28

# Сериализация в бинарный формат (bytes).
# SerializeToString() преобразует объект msg в последовательность байтов согласно схеме Protobuf.
serialized_data = msg.SerializeToString()

# ParseFromString заполняет msg2 данными из serialized_data.
# Метод разбирает байты, распознает теги (1 для name, 2 для age) и присваивает значения полям msg2.
msg2 = person_pb2.Person()
msg2.ParseFromString(serialized_data)

print("Person:", msg2.name)
print("Age:", msg2.age)
```

#### FlatBuffers

**Шаг 1.** Определим схему в файле `person.fbs`:

```fbs
// Определяем пространство имен (namespace) для сгенерированного кода, чтобы избежать конфликтов имен, особенно если у много схем. Все объекты из этой схемы будут помещены в модуль Example (например, Example/Person.py в Python).
namespace Example;

table Person {
    name: string;
    age: int;
}

/* 
    Указываем, что Person — корневой тип данных в буфере. FlatBuffers требует знать, какой объект является "точкой входа" в буфер. Это нужно для десериализации — чтобы GetRootAsPerson знал, с чего начинать.
    При десериализации буфера (например, Person.GetRootAsPerson(buf, 0)) FlatBuffers будет ожидать, что буфер содержит объект Person.
*/
root_type Person;
```

**Шаг 2.** Скомпилируем схему в Python-код (используя [flatc](https://github.com/google/flatbuffers)):

```bash
flatc --python person.fbs
```

Будут сгенерированы файлы, например `Person.py` и директория `Example` (зависит от вашей версии `flatc`).

**Шаг 3.** Использование в Python-коде:

```python
import flatbuffers
import Example.Person as Person  # Импортируем сгенерированный модуль.

# Сериализация.
# Создаем объект Builder — это основной инструмент для построения буфера FlatBuffers.
# initialSize=1024 задает начальный размер буфера в байтах (1024 байта), чтобы избежать частого перераспределения памяти.
builder = flatbuffers.Builder(initialSize=1024)

# Создаем строковый оффсет (указатель) для поля "name".
# Метод CreateString записывает строку "Pawel" в буфер (длина + байты UTF-8) и возвращает смещение (offset),
# указывающее, где эта строка находится в буфере.
name_offset = builder.CreateString("Pawel")

# Начинаем построение объекта Person в буфере.
# PersonStart подготавливает таблицу для объекта Person, выделяя место для указателей на поля (name и age).
Person.PersonStart(builder)

# Добавляем поле name в таблицу Person.
# PersonAddName принимает смещение строки (name_offset), которое мы создали ранее, и записывает его в таблицу.
Person.PersonAddName(builder, name_offset)

# Добавляем поле age в таблицу Person.
# PersonAddAge записывает число 28 напрямую (int занимает 4 байта), без создания отдельного оффсета, так как это примитивный тип.
Person.PersonAddAge(builder, 28)

# Завершаем построение объекта Person.
# PersonEnd фиксирует таблицу, возвращая смещение (offset) на начало этой таблицы в буфере.
person_obj = Person.PersonEnd(builder)

# Завершаем построение всего буфера.
# Finish сообщает Builder, что person_obj — это корневой объект, и добавляет служебные байты в начало буфера (например, указатель на таблицу).
builder.Finish(person_obj)

# Получаем итоговый бинарный буфер.
# Output возвращает все данные, собранные в Builder, в виде байтовой строки (bytes), готовой для сохранения или передачи.
buf = builder.Output()

# Дecериализация.
# GetRootAsPerson — это статический метод, который интерпретирует буфер как объект Person.
# Первый аргумент — буфер (buf), второй — смещение (0), указывающее, с какого байта начинать чтение (обычно 0 для корневого объекта).
person_msg = Person.Person.GetRootAsPerson(buf, 0)

# Извлекаем поле name из десериализованного объекта.
# Name() возвращает строку в виде байтов (bytes), так как FlatBuffers хранит строки в UTF-8.
# decode("utf-8") преобразует байты в строку Python, что важно для не-ASCII символов (хотя "Pawel" — ASCII, это хорошая практика).
name = person_msg.Name().decode("utf-8")  

# Извлекаем поле age из десериализованного объекта.
# Age() возвращает значение int напрямую, так как это примитивный тип, хранимый в буфере в готовом виде.
age = person_msg.Age()

print("Name:", name)
print("Age:", age)
```

---

### Производительность

- **Protobuf**:
    - Обычно показывает небольшие размеры сообщений, так как использует varint для целых чисел.
    - Требует парсинга, который создаёт дополнительные структуры в памяти, что может быть не так критично для
      микросервисов, но заметно в ресурсозатратных приложениях.
    - Имеет хорошую производительность при работе с gRPC.

- **FlatBuffers**:
    - Zero-copy десериализация делает его чрезвычайно быстрым при частом доступе к данным.
    - Сокращение объёмов памяти за счёт отсутствия дополнительного копирования данных.
    - В больших игровых движках и мобильных приложениях этот подход даёт значительные преимущества в скорости и
      потреблении памяти.

---

### Дополнительные аспекты

1. **Безопасность**:
    - Protobuf игнорирует неизвестные поля, что может быть как плюсом (не ломает старый код), так и минусом (сложнее
      отлавливать лишние/вредоносные данные).
    - FlatBuffers работает с указателями (смещениями) внутри буфера: важно следить, чтобы данные не были повреждены,
      иначе возможны «выходы за границы» при чтении.

2. **Читаемость**:
    - Оба формата по умолчанию бинарные и нечитабельны для человека.
    - Существуют инструменты для преобразования в JSON-подобный вид (для отладки и тестов).

3. **RPC**:
    - Protobuf имеет встроенную поддержку в gRPC (определения сервисов и методов в `.proto`).
    - FlatBuffers не привязан к какому-то одному RPC-фреймворку; возможно использовать сторонние решения или собственный
      фрэймворк.

4. **Специальные типы**:
    - Protobuf имеет well-known types (например, `Timestamp`, `Duration` и др.).
    - В FlatBuffers придётся объявлять собственные типы для дат, времени и т.п.

---

### Вместо вывода

- **Protobuf**:
    - Оптимален для микросервисов, сетевых RPC, проектов, где важна интеграция с gRPC и широкая языковая поддержка.
    - Более «классический» и легко осваиваемый подход к сериализации.

- **FlatBuffers**:
    - Хорош в случаях, когда каждый байт памяти важен (игры, VR/AR, мобильные приложения) и когда требуется очень
      быстрый доступ к любому полю без распаковки всего сообщения.
    - Пригодится в задачах, где нужно сериализовать/десериализовать очень большие объёмы данных с минимальными
      оверхедами.

Таким образом, выбор зависит от требований к производительности, ограничений по памяти, интеграции с существующими
инструментами и потребностей эволюции схем. Оба формата хорошо себя зарекомендовали, но имеют разные сильные и слабые
стороны.
