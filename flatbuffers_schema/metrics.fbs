namespace flatbuffers_schema;

table ServerMetrics {
  server_id: string;  // UTF-8-cтрока, хранится как длина (4 байта) + байты данных.
  cpu_usage: float;  // 32-битное число с плавающей точкой, 4 байта.
  memory_usage: float;
  disk_usage: float;
  timestamp: string;
}

/*
    Особенности table:
    * Поля опциональны: если поле не задано, оно не сериализуется в буфер.
    * Использует таблицу смещений (offsets): каждое поле в буфере представлено указателем (offset), который либо указывает на данные, либо отсутствует (нулевое смещение).
    * Поддерживает сложные типы: строки, массивы, вложенные таблицы.

    table Person {
      name: string;
      age: int;
    }

    Если сериализовать объект только с name="Pawel", не указав age, буфер будет содержать только данные для name, а age просто пропустится:

    [04 00 00 00] [08 00] [00 00] [05 00 00 00] [50 61 77 65 6C]
     служебные     таблица (name offset, age=0)  "Pawel"

    Преимущества:
    * Гибкость: можно добавлять или пропускать поля без изменения структуры буфера.
    * Экономия места: ненужные поля не занимают память.
    Недостатки:
    * Дополнительный оверхед из-за таблицы offsets (2-4 байта на поле).

    ---

    Особенности struct:
    * Все поля обязательны: каждое поле должно быть задано при сериализации.
    * Фиксированный размер: данные записываются подряд без offsets, что делает буфер компактнее.
    * Поддерживает только примитивные типы (int, float, bool и т.д.), но не строки или массивы.

    struct Point {
      x: float;
      y: float;
    }

    Для объекта Point {x: 1.0, y: 2.0} буфер будет фиксированным:

    [00 00 80 3F] [00 00 00 40]
     x=1.0         y=2.0

    Здесь нет offsets, только 8 байтов данных (4 на float).

    Преимущества:
    * Компактность: нет таблиц, только чистые данные.
    * Скорость: прямой доступ без указателей.
    Недостатки:
    * Cтроки не поддерживаются в struct.
    * Жесткость: нельзя пропустить поле или изменить структуру без пересоздания буфера.
*/

table MetricsRequest {  // Определяем таблицу MetricsRequest, которая содержит массив записей ServerMetrics.
  metrics: [ServerMetrics];  // Вектор (массив) объектов типа ServerMetrics. В буфере это будет закодировано как длина массива (4 байта) + смещения на каждый элемент. Массив может быть пустым, и это тоже валидный буфер.
}

root_type MetricsRequest;
/*
    Корневой тип данных в буфере (FlatBuffers требует явно указать корневой тип, чтобы знать, с чего начинать десериализацию).
    Здесь это означает, что буфер будет интерпретироваться как объект MetricsRequest и будет обеспечивать точку входа для чтения данных (например, через MetricsRequest.GetRootAsMetricsRequest).
*/
